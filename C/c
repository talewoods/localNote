char* 与 char[]区别

char* s1的s1是指针，指针指向一块内存区域，它指向的内存区域的大小可以随时改变，而且当指针指向常量字符串时，它的内容是不能被修改的；
char s2[]的s2是数组对应着一块内存区域，其地址和容量在生命期里不会改变，只有数组的内容可以改变；


C 语言深度解析

数组与指针

         int* p;
              p称为指针变量，p里存储的内存地址处的内存称为p所指向的内存。指针变量p里面存储的任何数据都将被当作地址处理。


         int* p=null 和 *p=null

              int* p=null;
              定义一个指针变量p，其指向的内存里面保存的是int类型的数据；在定义变量p的同时把p的值设置为0x0，而不是把*p的值设置为0x0；这个过程为初始化。
         
              int *p； *p=null;
              定义了一个指针变量p，其指向的内存里面保存的是int类型的数据；但是这个时候变量p本身的值是多少不得而知，也就是说现在变量p保存的可能是一个非法地址。
              *p=null，即给p指向的内存赋值为NULL；但此时p指向的内存可能是非法的。

              int i=10; int* p=&i; *p=NULL;
              p指向的内存由原来的10变为0了；而p本身的值，即内存地址没有改变；
             
              NULL，0，'\0'
              当常量0处于应该作为指针使用的上下文时，它就做为空指针使用；
                 int *p=0； 不会警告
                 int *p=3； 会警告
              '\0'是一个空字符的常量，它表示一个字符串的结束，它的ASCII值为0；
                 char str[]={'a','b',NULL}; 警告
                 char str[]={'a','b',0} 不会警告

编译器的bug

            char ch=10;
            char *p=(char*)0x12ff7c;
            *p=NULL
            p=NULL

数组的内存空间

           int a[5];
               定义一个数组a时，编译器根据指定的元素个数和元素的类型分配确定大小的一块内存，并把这块内存命名为a。名字a一旦与这块内存匹配就不能改变。
               a[0],a[1]等为a的元素，但并不是元素的名字，数组的每一个元素都是没有名字。

           sizeof()是关键字不是函数，函数求值是在运行时，而关键字求值是在编译的时候；
           &a 表示的是数组的首地址  &a[0] 表示的是数组首元素的地址，值一样但是意义不同
        
           左值与右值  x=y
               左值：在这个上下文环境中，编译器认为x的含义为x所代表的内存区域，这个区域的地址只有编译器知道，在编译的时候确定；
               右值：在这个上下文环境中，编译器认为y的含义为y所代表的内存区域中的值；
               数组作为右值时，代表a的首元素的地址；数组不能作为左值；
               
